package me.accessmodifier364.leuxbackdoor.client.modules.exploit;

import me.accessmodifier364.leuxbackdoor.client.guiscreen.settings.Setting;
import me.accessmodifier364.leuxbackdoor.client.modules.Category;
import me.accessmodifier364.leuxbackdoor.client.modules.Module;
import me.accessmodifier364.leuxbackdoor.client.util.BlockUtil;
import me.accessmodifier364.leuxbackdoor.client.util.InventoryUtil;
import me.accessmodifier364.leuxbackdoor.client.util.PlayerUtil;
import net.minecraft.block.Block;
import net.minecraft.block.BlockChest;
import net.minecraft.block.BlockEnderChest;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

public class InstantBurrow extends Module {
    public InstantBurrow() {
        super(Category.exploit);
        this.name = "InstantBurrow";
        this.description = "you are really gay";
    }


    Setting type = create("Mode", "Mode", "Packet", combobox("Packet", "Normal"));
    Setting block = create("Block", "Block", "EChest", combobox("Any", "EChest", "Chest"));
    Setting force = create("Height", "Height", 1.5, -5.0, 10.0);
    Setting rotate = create("Rotate", "Rotate", false);
    Setting instant = create("Instant", "Instant", true);
    Setting center = create("Center", "Center", false);
    Setting bypass = create("Bypass", "Bypass", false);

    int swapBlock = -1;
    Vec3d centerBlock = Vec3d.ZERO;
    BlockPos oldPos;
    Block blockW = Blocks.OBSIDIAN;
    boolean flag;

    @Override
    public void enable() {
        flag = false;

        mc.player.motionX = 0;
        mc.player.motionZ = 0;

        centerBlock = this.getCenter(mc.player.posX, mc.player.posY, mc.player.posZ);
        if (centerBlock != Vec3d.ZERO && center.get_value(true)) {
            double x_diff = Math.abs(centerBlock.x - mc.player.posX);
            double z_diff = Math.abs(centerBlock.z - mc.player.posZ);
            if (x_diff <= 0.1 && z_diff <= 0.1) {
                centerBlock = Vec3d.ZERO;
            } else {
                double motion_x = centerBlock.x - mc.player.posX;
                double motion_z = centerBlock.z - mc.player.posZ;
                mc.player.motionX = motion_x / 2;
                mc.player.motionZ = motion_z / 2;
            }
        }

        oldPos = PlayerUtil.getPlayerPos();
        if(block.in("Any"))
            swapBlock = PlayerUtil.findObiInHotbar();
        if(block.in("EChest"))
            swapBlock = InventoryUtil.findHotbarBlockz(BlockEnderChest.class);
        if(block.in("Chest"))
            swapBlock = InventoryUtil.findHotbarBlockz(BlockChest.class);


        if (swapBlock == -1) {
            this.disable();
            return;
        }
        if (instant.get_value(true)) {
            mc.timer.tickLength = 1f;
        }
        if (type.in("Normal")) {
            mc.player.jump();
        }
    }

    @Override
    public void update() {
        if (type.in("Normal")) {
            if (mc.player.posY > (oldPos.getY() + 1.04)) {
                int old = mc.player.inventory.currentItem;
                this.switchToSlot(swapBlock);
                BlockUtil.placeBlock(oldPos, EnumHand.MAIN_HAND, rotate.get_value(true), true, false);
                this.switchToSlot(old);
                mc.player.motionY = force.get_value(1);
                toggle();
            }
        } if(type.in("Packet")) {
            mc.player.connection.sendPacket(
                    new CPacketPlayer.Position(
                            mc.player.posX,
                            mc.player.posY + 0.41999998688698,
                            mc.player.posZ,
                            true
                    )
            );
            mc.player.connection.sendPacket(
                    new CPacketPlayer.Position(
                            mc.player.posX,
                            mc.player.posY + 0.7531999805211997,
                            mc.player.posZ,
                            true
                    )
            );
            mc.player.connection.sendPacket(
                    new CPacketPlayer.Position(
                            mc.player.posX,
                            mc.player.posY + 1.00133597911214,
                            mc.player.posZ,
                            true
                    )
            );
            mc.player.connection.sendPacket(
                    new CPacketPlayer.Position(
                            mc.player.posX,
                            mc.player.posY + 1.16610926093821,
                            mc.player.posZ,
                            true
                    )
            );
            int old = mc.player.inventory.currentItem;
            this.switchToSlot(swapBlock);
            BlockUtil.placeBlock(oldPos, EnumHand.MAIN_HAND, rotate.get_value(true), true, false);
            this.switchToSlot(old);
            mc.player.connection.sendPacket(
                    new CPacketPlayer.Position(
                            mc.player.posX,
                            mc.player.posY + force.get_value(1),
                            mc.player.posZ,
                            false
                    )
            );
            if(bypass.get_value(true) && !mc.player.isSneaking()) {
                mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_SNEAKING));
                mc.player.setSneaking(true);
                mc.playerController.updateController();
                mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.STOP_SNEAKING));
                mc.player.setSneaking(false);
                mc.playerController.updateController();
            }
            this.toggle();
        }
    }

    @Override
    public void disable(){
        if(instant.get_value(true)){
            mc.timer.tickLength = 50f;
        }
    }

    private void switchToSlot(final int slot) {
        mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
        mc.player.inventory.currentItem = slot;
        mc.playerController.updateController();
    }

    private Vec3d getCenter(double posX, double posY, double posZ) {
        double x = Math.floor(posX) + 0.5D;
        double y = Math.floor(posY);
        double z = Math.floor(posZ) + 0.5D ;

        return new Vec3d(x, y, z);
    }

    public void setBlock(Block b){
        this.blockW = b;
    }

    public Block getBlock(){
        return this.blockW;
    }
    
    /*
    Setting rotate = create("Rotate", "Rotate", false);
    Setting silent = create("Silent", "Silent", true);
    Setting enderchest = create("Ender Chest", "EnderChest", true);
    Setting height = create ("Height", "Height", 3, 0, 10);
    Setting noAntiCheat = create("NoAntiCheat", "NoAntiCheat", false);

    float oldTickLength = mc.timer.tickLength;

    @Override
    public void enable() {
        if (mc.player == null || mc.world == null) return;

        final int oldSlot = mc.player.inventory.currentItem;
        oldTickLength = mc.timer.tickLength;
        BlockPos originalPos = new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ);

        if (mc.world.getBlockState(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ)).getBlock().equals(Blocks.OBSIDIAN) || mc.world.getBlockState(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ)).getBlock().equals(Blocks.ENDER_CHEST)) {
            MessageUtil.send_client_message("You are already in Obsidian / Ender Chest");
            set_disable();
            return;
        } else if (isInterceptedByOther(originalPos)) {
            MessageUtil.send_client_message("You are intercepted by an entity");
            set_disable();
            return;
        } else if (getHotbarSlot(Blocks.OBSIDIAN) == -1 && getHotbarSlot(Blocks.ENDER_CHEST) == -1) {
            MessageUtil.send_client_message("You don't have Obsidian or EnderChest in your hotbar");
            set_disable();
            return;
        } else if (!mc.world.getBlockState(originalPos.add(0, 1, 0)).getBlock().equals(Blocks.AIR) || !mc.world.getBlockState(originalPos.add(0, 2, 0)).getBlock().equals(Blocks.AIR) || !mc.world.getBlockState(originalPos.add(0, 3, 0)).getBlock().equals(Blocks.AIR)) {
            MessageUtil.send_client_error_message("Not enough space!");
            this.set_disable();
            return;
        } else if (mc.isSingleplayer()) {
            MessageUtil.send_client_error_message("You are in singleplayer!");
            set_disable();
            return;
        }

        if (silent.get_value(true)) mc.timer.tickLength = 1f;

        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.41999998688698D, mc.player.posZ, true));
        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.7531999805211997D, mc.player.posZ, true));
        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 1.00133597911214D, mc.player.posZ, true));
        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 1.16610926093821D, mc.player.posZ, true));
        mc.player.setPosition(mc.player.posX, mc.player.posY + 1.16610926093821D, mc.player.posZ);

        if (enderchest.get_value(true) && getHotbarSlot(Blocks.ENDER_CHEST) != -1) {
            mc.player.inventory.currentItem = getHotbarSlot(Blocks.ENDER_CHEST);
        } else if (getHotbarSlot(Blocks.OBSIDIAN) != -1) {
            mc.player.inventory.currentItem = getHotbarSlot(Blocks.OBSIDIAN);
        } else {
            mc.player.inventory.currentItem = getHotbarSlot(Blocks.ENDER_CHEST);
        }

        placeBlock(originalPos, rotate.get_value(true),  true, false, true, false);
        mc.player.inventory.currentItem = oldSlot;
        mc.player.setPosition(mc.player.posX, mc.player.posY - 1.16610926093821D, mc.player.posZ);

        if (noAntiCheat.get_value(true)) {
            mc.player.connection.sendPacket(new CPacketPlayer.Position(originalPos.getX(), originalPos.getY(), originalPos.getZ(), true));
        } else {
            mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + height.get_value(1), mc.player.posZ, true));
        }

        mc.timer.tickLength = oldTickLength;
        set_disable();
    }

    public static boolean isIntercepted(BlockPos pos) {
        for (Entity entity : mc.world.loadedEntityList) {
            if (new AxisAlignedBB(pos).intersects(entity.getEntityBoundingBox()) && !(entity instanceof EntityItem))
                return true;
        }
        return false;
    }

    public static boolean isInterceptedByOther(final BlockPos pos) {
        for (final Entity entity : mc.world.loadedEntityList) {
            if (entity.equals(mc.player)) continue;
            if (new AxisAlignedBB(pos).intersects(entity.getEntityBoundingBox()) && !(entity instanceof EntityItem)) return true;
        }
        return false;
    }

    public static int getHotbarSlot(final Block block) {
        for (int i = 0; i < 9; i++) {
            final Item item = mc.player.inventory.getStackInSlot(i).getItem();
            if (item instanceof ItemBlock && ((ItemBlock) item).getBlock().equals(block)) return i;
        }
        return -1;
    }

    public static void placeBlock(BlockPos pos, boolean rotate, boolean raytrace, boolean packet, boolean swingArm, boolean antiGlitch) {
        for (EnumFacing enumFacing : EnumFacing.values()) {
            if (!(getBlockResistance(pos.offset(enumFacing)) == BlockResistance.Blank) && !isIntercepted(pos)) {
                Vec3d vec = new Vec3d(pos.getX() + 0.5D + (double) enumFacing.getXOffset() * 0.5D, pos.getY() + 0.5D + (double) enumFacing.getYOffset() * 0.5D, pos.getZ() + 0.5D + (double) enumFacing.getZOffset() * 0.5D);

                float[] old = new float[] {
                        mc.player.rotationYaw, mc.player.rotationPitch
                };

                if (rotate)
                    mc.player.connection.sendPacket(new CPacketPlayer.Rotation((float) Math.toDegrees(Math.atan2((vec.z - mc.player.posZ), (vec.x - mc.player.posX))) - 90.0F, (float) (-Math.toDegrees(Math.atan2((vec.y - (mc.player.posY + (double) mc.player.getEyeHeight())), (Math.sqrt((vec.x - mc.player.posX) * (vec.x - mc.player.posX) + (vec.z - mc.player.posZ) * (vec.z - mc.player.posZ)))))), mc.player.onGround));

                mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_SNEAKING));

                if (packet)
                    mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(pos, raytrace ? enumFacing : EnumFacing.UP, EnumHand.MAIN_HAND, 0, 0, 0));
                else
                    mc.playerController.processRightClickBlock(mc.player, mc.world, pos.offset(enumFacing), raytrace ? enumFacing.getOpposite() : EnumFacing.UP, new Vec3d(pos), EnumHand.MAIN_HAND);

                if (swingArm)
                    mc.player.swingArm(EnumHand.MAIN_HAND);

                mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.STOP_SNEAKING));

                if (rotate)
                    mc.player.connection.sendPacket(new CPacketPlayer.Rotation(old[0], old[1], mc.player.onGround));

                if (antiGlitch)
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos.offset(enumFacing), enumFacing.getOpposite()));

                return;
            }
        }
    }

    @SuppressWarnings("deprecation")
    public static BlockResistance getBlockResistance(BlockPos block) {
        if (mc.world.isAirBlock(block))
            return BlockResistance.Blank;

        else if (mc.world.getBlockState(block).getBlock().getBlockHardness(mc.world.getBlockState(block), mc.world, block) != -1 && !(mc.world.getBlockState(block).getBlock().equals(Blocks.OBSIDIAN) || mc.world.getBlockState(block).getBlock().equals(Blocks.ANVIL) || mc.world.getBlockState(block).getBlock().equals(Blocks.ENCHANTING_TABLE) || mc.world.getBlockState(block).getBlock().equals(Blocks.ENDER_CHEST)))
            return BlockResistance.Breakable;

        else if (mc.world.getBlockState(block).getBlock().equals(Blocks.OBSIDIAN) || mc.world.getBlockState(block).getBlock().equals(Blocks.ANVIL) || mc.world.getBlockState(block).getBlock().equals(Blocks.ENCHANTING_TABLE) || mc.world.getBlockState(block).getBlock().equals(Blocks.ENDER_CHEST))
            return BlockResistance.Resistant;

        else if (mc.world.getBlockState(block).getBlock().equals(Blocks.BEDROCK))
            return BlockResistance.Unbreakable;

        return null;
    }

    public enum BlockResistance {
        Blank,
        Breakable,
        Resistant,
        Unbreakable
    }
     */
}