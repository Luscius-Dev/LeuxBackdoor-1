package me.accessmodifier364.leuxbackdoor.client.modules.exploit;

import me.accessmodifier364.leuxbackdoor.client.event.EventCancellable;
import me.accessmodifier364.leuxbackdoor.client.event.events.EventPacket;
import me.accessmodifier364.leuxbackdoor.client.guiscreen.settings.Setting;
import me.accessmodifier364.leuxbackdoor.client.modules.Category;
import me.accessmodifier364.leuxbackdoor.client.modules.Module;
import me.accessmodifier364.leuxbackdoor.client.util.MathUtil;
import me.accessmodifier364.leuxbackdoor.client.util.Timer;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketKeepAlive;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class PingSpoof extends Module {
    public PingSpoof() {
        super(Category.exploit);
        this.name        = "PingSpoof";
        this.description = "i have 500 ms, u are ping player";
    }

    Setting seconds = create("Seconds", "PSSeconds", false);
    Setting delay = create("Delay MS", "PSDelay", 20, 0, 1000);
    Setting secondDelay = create("Delay Seconds", "PSDelayS", 5, 0, 30);
    private final Queue<Packet<?>> packets = new ConcurrentLinkedQueue();
    private final me.accessmodifier364.leuxbackdoor.client.util.Timer timer = new Timer();
    private boolean receive = true;

    @EventHandler
    private final Listener<EventPacket.SendPacket> event = new Listener<>(event -> {
        if (receive && mc.player != null && !mc.isSingleplayer() && mc.player.isEntityAlive() && event.get_era() == EventCancellable.Era.EVENT_PRE && event.get_packet() instanceof CPacketKeepAlive) {
            packets.add(event.get_packet());
            event.cancel();
        }
    });

    @Override
    public void update() {
        clearQueue();
    }

    @Override
    public void disable() {
        clearQueue();
    }

    public void clearQueue() {
        if (mc.player != null && !mc.isSingleplayer() && mc.player.isEntityAlive() && (!seconds.get_value(true) && timer.passedMs(delay.get_value(1)) || seconds.get_value(true) && timer.passedS(secondDelay.get_value(1)))) {
            double limit = MathUtil.getIncremental(Math.random() * 10.0, 1.0);
            receive = false;
            int i = 0;
            while ((double)i < limit) {
                Packet<?> packet = packets.poll();
                if (packet != null) {
                    mc.player.connection.sendPacket(packet);
                }
                ++i;
            }
            timer.reset();
            receive = true;
        }
    }
}
