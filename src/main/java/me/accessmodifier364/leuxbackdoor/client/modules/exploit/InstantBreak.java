package me.accessmodifier364.leuxbackdoor.client.modules.exploit;

import me.accessmodifier364.leuxbackdoor.client.event.events.EventDamageBlock;
import me.accessmodifier364.leuxbackdoor.client.event.events.EventPacket;
import me.accessmodifier364.leuxbackdoor.client.event.events.EventRender;
import me.accessmodifier364.leuxbackdoor.client.guiscreen.settings.Setting;
import me.accessmodifier364.leuxbackdoor.client.modules.Category;
import me.accessmodifier364.leuxbackdoor.client.modules.Module;
import me.accessmodifier364.leuxbackdoor.client.util.RenderUtil;
import me.accessmodifier364.leuxbackdoor.client.util.Timer;
import me.accessmodifier364.leuxbackdoor.client.util.turok.draw.RenderHelp;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Items;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

import java.awt.*;

public class InstantBreak extends Module {
    public InstantBreak() {
        super(Category.exploit);
        this.name        = "InstantBreak";
        this.description = "funny exploit";
    }

    private BlockPos renderBlock;
    private BlockPos lastBlock;
    private boolean packetCancel = false;
    private final me.accessmodifier364.leuxbackdoor.client.util.Timer breaktimer = new Timer();
    private EnumFacing direction;

    Setting autoBreak = create("Auto Break", "AutoBreak", true);
    Setting delay = create("Delay", "Delay", 20, 0, 300);
    Setting picOnly = create("Only Pickaxe", "OnlyPickaxe", true);
    Setting red = create("Red", "Red", 255, 0, 255);
    Setting green = create("Green", "Green", 255, 0, 255);
    Setting blue = create("Blue", "Blue", 0, 0, 255);
    Setting alpha = create("Alpha", "Alpha", 70, 0, 255);

    @Override
    public void render(EventRender event) {
        if (renderBlock != null) {
            drawBlock(renderBlock, red.get_value(1), green.get_value(1), blue.get_value(1), alpha.get_value(1));
        }
    }

    private void drawBlock(BlockPos blockPos, int r, int g, int b, int a) {
        RenderHelp.prepare("quads");
        RenderUtil.drawBox(blockPos, new Color(r, g, b, a), true, true);
        RenderHelp.release();
    }

    @Override
    public void update() {
        if(renderBlock != null) {
            if(autoBreak.get_value(true) && breaktimer.passed(delay.get_value(1))) {
                if(picOnly.get_value(true)&&!(mc.player.getHeldItem(EnumHand.MAIN_HAND).getItem() == Items.DIAMOND_PICKAXE)) return;
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                        renderBlock, direction));
                breaktimer.reset();
            }

        }

        try {
            mc.playerController.blockHitDelay = 0;

        } catch (Exception ignored) {
        }
    }

    @EventHandler
    private final Listener<EventPacket.SendPacket> packetSendListener = new Listener<>(event -> {
        Packet packet = event.get_packet();
        if (packet instanceof CPacketPlayerDigging) {
            if(((CPacketPlayerDigging) packet).getAction()== CPacketPlayerDigging.Action.START_DESTROY_BLOCK && packetCancel) event.cancel();
        }
    });

    @EventHandler
    private final Listener<EventDamageBlock> OnDamageBlock = new Listener<>(p_Event -> {
        if (canBreak(p_Event.getPos())) {
            if (lastBlock==null||p_Event.getPos().getX()!=lastBlock.getX() || p_Event.getPos().getY()!=lastBlock.getY() || p_Event.getPos().getZ()!=lastBlock.getZ()) {
                packetCancel = false;
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                        p_Event.getPos(), p_Event.getDirection()));
            }
            packetCancel = true;
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                    p_Event.getPos(), p_Event.getDirection()));

            renderBlock = p_Event.getPos();
            lastBlock = p_Event.getPos();
            direction = p_Event.getDirection();

            p_Event.cancel();

        }
    });

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();

        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public BlockPos getTarget(){
        return renderBlock;
    }

    public void setTarget(BlockPos pos){
        renderBlock = pos;
        packetCancel = false;
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                pos, EnumFacing.DOWN));
        packetCancel = true;
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                pos, EnumFacing.DOWN));
        direction = EnumFacing.DOWN;
        lastBlock = pos;
    }
}